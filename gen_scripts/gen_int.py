@{
import inspect
import fileinput,os,string,re,sys
import time
from math import *
sys.path.append(".")
license_string = """////////////////////////////////////////////////////////////////////////////// 
// Copyright© 2013 by Broadcom Corporation. All Rights reserved.
// Original Author : Tony Kirke, Broadcom Corporation.
// This software is available under both the SystemC Open Source License 
// Version 3.1 and the MIT License
//
// The contents of this file are subject to the restrictions and limitations
// set forth in the SystemC Open Source License Version 3.1 (the "License").
// You may not use this file except in compliance with such restrictions and
// limitations. You may obtain instructions on how to receive a copy of the
// License at http://www.accellera.org/. Software distributed by Contributors
// under the License is distributed exclusively on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied.
// See the License for the specific language governing rights and limitations
// under the License.
////////////////////////////////////////////////////////////////////////////// 
// MIT License info:
// Permission is hereby granted, free of charge, to any person obtaining a copy 
// of this software and associated documentation files (the "Software"), to deal 
// in the Software without restriction, including without limitation the rights 
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all 
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
// USE OR OTHER DEALINGS IN THE SOFTWARE.
//
////////////////////////////////////////////////////////////////////////////// 
"""

uint_types = ['uint8_t','uint16_t','uint32_t','uint64_t']
sint_types = ['int8_t','int16_t','int32_t','int64_t']
int_types = ['int8_t','int16_t','int32_t','int64_t','uint8_t','uint16_t','uint32_t','uint64_t']
base_types = ['int8_t','int16_t','int32_t','int64_t','uint8_t','uint16_t','uint32_t','uint64_t','double']

string_types = ['dec','oct','hex']

assign_form_types = ['double']
assign_form1_types = int_types
div_form_types = base_types

dbg_string = 'std::cout << "At line: " << __LINE__ << " " << __PRETTY_FUNCTION__ << "\\n";'
dbg_string = ' ';

Namespace = 'sc_ft'
UNamespace = Namespace.upper()

GenDate = time.strftime("%Y/%m/%d")
Version = time.strftime("%Y%m%d")

# Most Capitalize strings are Empy Variables
Class = empy.args[0]
UClass = Class.upper()
IClass = empy.args[1]
ClassIsSigned = empy.args[2]

Header_inc = "SYSTEMC_"+UNamespace+"_"+UClass+"_"+Version+"_CLASSES_H_"

Subrefs = 'ok'

if (ClassIsSigned == 'signed'):
	DataType = 'signed'
	SatFunc = 'saturate'
	SignedType = Class
else:
	DataType = 'unsigned'
	SatFunc = 'usaturate'
	SignedType = IClass

# adds std::cout , etc stuff
extra_stuff = None
add_license_file = open("license.txt").read()

}@
// DO NOT EDIT THIS FILE IT WAS AUTOMATICALLY GENERATED ON @(GenDate)
@(add_license_file)
////////////////////////////////////////////////////////////////////////////// 

#ifndef @(Header_inc)
#define @(Header_inc)
#include <iostream>
#include <sstream>
#include <cmath> // for floor in sc_fixed
#include <@(Namespace)/sc_common.h>
#include <@(Namespace)/sc_int_bitref.h>
#include <@(Namespace)/sc_uint_bitref.h>
#include <@(Namespace)/sc_int_subref.h>
#include <@(Namespace)/sc_uint_subref.h>

namespace @(Namespace) {

	/// A faster version of the older systemc @(Class)
	template <int I_> class @(Class) {
	public:
@{
if (DataType == 'signed'):
	print "\t\ttypedef typename int_type_size<NEXT_INT_SIZE<I_>::val>::int_type val_type;"
	print "\t\ttypedef int64_t max_val_type;"
else:
	print "\t\ttypedef typename int_type_size<NEXT_INT_SIZE<I_>::val>::uint_type val_type;"
	print "\t\ttypedef uint64_t max_val_type;"
}@
		val_type val;
@{
if (Subrefs == 'ok'):
	print "#ifndef NO_LHS_RANGE"
	print "\t\t"+Class+"_subref<I_> subref;"
	print "\t\t"+Class+"_bitref<I_> bitref;"
	print "#endif"
}@
		static const int INTEGER_BITS = I_;



		public:
		/// constructors
		@(Class)() : val(0) {	}
		
		/// From exact same type - just copy val
		@(Class)(const @(Class)& a) : val(a.getVal()) {	}
		@(Class)(const double& a) : val((int64_t)a) {	}
@{
print "\t\t// Constructors (generated)"
if (ClassIsSigned == 'signed'):
  for t in int_types:
      print "\t\t"+Class+"(const "+t+"& a) : val((int64_t)a) {	}"
else:
  for t in int_types:
      print "\t\t"+Class+"(const "+t+"& a) { val = a & UMask<I_>::val; }"
}@


		/// from another @(Class)<>
		template <int I_1> @(Class)(const @(Class)<I_1>& a) {
			val = a.val;
		}

		// for now
		val_type getVal() const { return(val); }

		/// Conversions
		void from_int(int64_t x) {	val = (max_val_type)x;	}
		double to_double(void) const { return((double)val);}
		int64_t to_int(void) const { return((int64_t)val); }

		// conversion to bool
@{ if extra_stuff: print "\toperator bool() const { return(val != 0); }"}@
		bool operator !() const { return(val == 0);}
		
		operator int64_t() const { return((int64_t)val); }
		

		@(Class)& operator ++() {
			val++;
			return *this;
		}
		@(Class) operator ++(int) { @(Class) tmp(*this); ++*this; return(tmp);}
		@(Class)& operator --() {
			val--;
			return *this;
		}
		@(Class) operator --(int) { @(Class) tmp(*this); --*this; return(tmp);}
		
		// assignment operator, just copy the only member variable - no checks!
		// could use copy constructor + swap?
		@(Class)& operator =(const @(Class)& a) {	
			val= a.getVal();
			return *this;
		}

	    template <int I_1> @(Class)(const @(Class)_subref<I_1>& a) : val((int64_t)a.val) {	}
	    template <int I_1> @(Class)(const @(Class)_bitref<I_1>& a) : val((int64_t)a.val) {	}
		template <int I_1> @(Class)& 
			operator =(const @(Class)_subref<I_1>& a) {	
			val= a.val;
			return *this;
		}
		template <int I_1> @(Class)& 
			operator =(const @(IClass)_subref<I_1>& a) {	
			val= a.val;
			return *this;
		}
		template <int I_1> @(Class)& 
			operator =(const @(Class)_bitref<I_1>& a) {	
			val= a.val;
			return *this;
		}
		template <int I_1> @(Class)& 
			operator =(const @(IClass)_bitref<I_1>& a) {	
			val= a.val;
			return *this;
		}
@{
lform = string.Template("""
#ifndef NO_LHS_RANGE
	  // Sub/bitref LHS Stuff
		${Class}_bitref<I_>& operator[](uint64_t i) {
			bool tmp = (val >> i) & 0x1;
			bitref.val = tmp;
			bitref.index = i;
			bitref.val_ptr = this;
			return bitref;
		}
		${Class}_subref<I_>& range(int lhs, int rhs) {
			uint64_t tmp = (val >> rhs) & ((1 << (lhs-rhs+1)) - 1);
			subref.val = tmp;
			subref.lhs = lhs;
			subref.rhs = rhs;
			subref.val_ptr = this;
			return subref;
		}
		${Class}_subref<I_>& range(int lhs, int rhs) const {
			subref.val = val;
			return subref;
		}
#endif
""")
if (Class == 'sc_int'):
   nstr = lform.substitute(Class='sc_int')
else:
   nstr = lform.substitute(Class='sc_uint')
if (Subrefs == 'ok'): print nstr
}@		
		/// assignment operator from another size, use copy constructor, then copy val;
		template <int I_1> @(Class)<I_>& operator =(const @(Class)<I_1>& a) {
			@(Class)<I_> temp(a);
			val = temp.getVal();
			return *this;
		}

		/// sign operator
		@(Class)<I_+1> operator -() const {
			@(Class)<I_+1> tmp(*this); tmp.val = -tmp.val;	return tmp; 
		} 
		@(Class)<I_> operator +() const {
			@(Class)<I_> tmp(*this);	return tmp; 
		} 

		/// bit flip
		@(Class) operator ~() const { 
			@(Class) tmp(*this); tmp.val = ~tmp.val; return(tmp);
		}

		// Assign from different built-in types
@{
for t in base_types:
    print "\t\t"+Class+"& operator = (const "+t+"& a) {*this = "+Class+"(a); return *this; }"
}@

		template <int I_1> @(Class)& operator +=(const @(Class)<I_1>& a) {
			val += a.val;
			return *this;
		}

		template <int I_1> @(Class)& operator -=(const @(Class)<I_1>& a) {
			*this += (-a); // re-use +=
			return *this;
		}

		template <int I_1> @(Class)& operator *=(const @(Class)<I_1>& b) {
			val *= b.val;
			return *this;
		}
@{
for t in int_types:
    print "\t\t"+Class+"& operator += (const "+t+"& b) {val += b;	return *this;}"
    print "\t\t"+Class+"& operator -= (const "+t+"& b) {val -= b;	return *this;}"
    print "\t\t"+Class+"& operator *= (const "+t+"& b) {val *= b;	return *this;}"
    print "\t\t"+Class+"& operator /= (const "+t+"& b) {val /= b;	return *this;}"
}@
		// "+= and -=" from different built-in types

		@(Class)& operator *=(const double& a) {@(Class) tmp(a); 
			val *= tmp.getVal();
			return *this; 
		}
		@(Class)& operator /=(const double& a) {@(Class) tmp(a); 
			val /= tmp.getVal();
			return *this; 
		}
		@(Class)& operator +=(const double& a) {@(Class) tmp(a); 
			val += tmp.getVal();
			return *this; 
		}
		@(Class)& operator -=(const double& a) {@(Class) tmp(a); 
			val -= tmp.getVal();
			return *this; 
		}
		@(Class)& operator >>=(const int& a) {
			val >>= a;
			return *this; 
		}
		@(Class)& operator <<=(const int& a) {
			val <<= a;
			return *this; 
		}

		template <typename T> @(Class)& operator &=(const T &l) {
			val &= l;	return *this;	
		}
		template <typename T> @(Class)& operator |=(const T &l) {
			val |= l;	return *this; 
		}
		template <typename T> @(Class)& operator ^=(const T &l) {
			val ^= l;	return *this;	
		}

@{
print "\t// Gen String Conversions"
for t in string_types:
	print "\t/// Warning Not Complete"
	print "\tstd::string to_"+t+"() const {"
	print "\t\tstd::stringstream ss;"
	print "\t\tss << std::"+t+" << to_int();"
	print "\t\treturn(ss.str());"
	print "\t}"

}@
	/// 
	std::string to_bin() const {
		std::stringstream ss;
		for (int i=I_-1;i>-1;i--) {
			bool b = (val >> i) & 0x1;
			if (b) ss << "1";
			else ss << "0";
		}
		return(ss.str());
	}

     /// Warning Not Complete
	 std::string to_string(sc_numrep numrep, bool with_prefix, sc_fmt FMT=SC_F) const {
	    std::string s;
	    switch(numrep) {
@{
for t in string_types:
		print "\t\t\tcase SC_"+t.upper()+": s = to_"+t+"(); break;"
}@
		    default: s = to_bin(); break;
	     }
     	 return(s);
     }

	
		/// Warning Not Complete
		void print( std::ostream& os = ::std::cout ) const { 
			os << to_int(); 
		}
		/// Warning Not Complete
		void scan( std::istream& is) { ;}
		
	}; // end of class 
	
	
} // end of namespace @(Namespace)

#endif
    

	

    
