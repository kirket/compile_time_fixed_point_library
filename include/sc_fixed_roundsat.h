// DO NOT EDIT THIS FILE IT WAS AUTOMATICALLY GENERATED 2013/07/10
////////////////////////////////////////////////////////////////////////////// 
// Copyright© 2013 by Broadcom Corporation. All Rights reserved.
// Original Author : Tony Kirke, Broadcom Corporation.
// This software is available under both the SystemC Open Source License 
// Version 3.1 and the MIT License
//
// The contents of this file are subject to the restrictions and limitations
// set forth in the SystemC Open Source License Version 3.1 (the "License").
// You may not use this file except in compliance with such restrictions and
// limitations. You may obtain instructions on how to receive a copy of the
// License at http://www.accellera.org/. Software distributed by Contributors
// under the License is distributed exclusively on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied.
// See the License for the specific language governing rights and limitations
// under the License.
////////////////////////////////////////////////////////////////////////////// 
// MIT License info:
// Permission is hereby granted, free of charge, to any person obtaining a copy 
// of this software and associated documentation files (the "Software"), to deal 
// in the Software without restriction, including without limitation the rights 
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all 
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
// USE OR OTHER DEALINGS IN THE SOFTWARE.
//
////////////////////////////////////////////////////////////////////////////// 
#ifndef SYSTEMC_SC_FT_SC_FIXED_20130710_ROUNDSAT_H_
#define SYSTEMC_SC_FT_SC_FIXED_20130710_ROUNDSAT_H_

// Type for smallest intX_t type needed for B bits such as int16_t for 12 bits
// rounding helper class - specialized for each round TYPE
// saturation helper class - specialized for each sat TYPE
// these allow generic use within sc_fixed class

namespace sc_ft {

	// forward declaration
#ifndef DOXYGEN_SHOULD_SKIP_THIS
	template <int TOTAL_BITS_, int FRAC_BITS_, sc_q_mode SC_Q_MODE_, sc_o_mode SC_O_MODE_> class sc_fixed;
	template <int TOTAL_BITS_, int FRAC_BITS_, sc_q_mode SC_Q_MODE_, sc_o_mode SC_O_MODE_> class sc_ufixed;
#endif
	
	/// A template class to wrap "round" functions that can be specialized for fixed-point types
	template <sc_q_mode Q_> class sc_round_class_function {
		public:
			// Default round function is truncate!!!
			template <typename T_, typename TS_>
				T_ round(const T_& a,const TS_& shift) {
				   T_ x = a >> shift;
				   return (x);
			    }
		}; // end of class 
		/// round return type one extra bit to avoid overflow,specialize other forms as needed
		template <> 
			class sc_round_class_function<SC_RND> {
		public:
			/// Specialized round function for SC_RND
			template <typename T_, typename TS_>
                 static T_ round(const T_& a,const TS_& shift) {
				   T_ x = a >> shift;
		    	   if (shift>0) x += (a >> (shift-1)) & 0x1;
				   return (x);
			     }
		};	
		/// Specialization for SC_TRN
		template <>
			class sc_round_class_function<SC_TRN> {
		public:
		    /// Specialized round function for SC_TRN
			template <typename T_, typename TS_>
				static T_ round(const T_& a,const TS_& shift) {
				   T_ x = a >> shift;
	     		   return (x);
			    }
		};	

     	/// A template class to wrap "shift" functions that can be specialized for fixed-point types
		template <int FRAC_BITS_, sc_q_mode Q_> class sc_shift_class_function {
		public:
			/// Default shift function is truncate!!!
			template <int TOTAL_BITS_1, int INT_BITS_1, sc_q_mode SC_Q_MODE_1, sc_o_mode SC_O_MODE_1>
				static typename int_size_needed<INT_BITS_1+Template_Max<TOTAL_BITS_1-INT_BITS_1,FRAC_BITS_>::maxval>::int_type
				shift_function(
							   const sc_fixed<TOTAL_BITS_1,INT_BITS_1,SC_Q_MODE_1,SC_O_MODE_1>& a) {
				typename int_size_needed<INT_BITS_1+Template_Max<TOTAL_BITS_1-INT_BITS_1,FRAC_BITS_>::maxval>::int_type x;
				if (TOTAL_BITS_1-INT_BITS_1>FRAC_BITS_) {
        			x = (a.getVal() >> Abs_Func<TOTAL_BITS_1-INT_BITS_1-FRAC_BITS_>::val);
				} else {
		        	x = (a.getVal() << Abs_Func<TOTAL_BITS_1-INT_BITS_1-FRAC_BITS_>::val);
				}
				return (x);
			}
			template <int TOTAL_BITS_1, int INT_BITS_1, sc_q_mode SC_Q_MODE_1, sc_o_mode SC_O_MODE_1>
				static typename int_size_needed<INT_BITS_1+Template_Max<TOTAL_BITS_1-INT_BITS_1,FRAC_BITS_>::maxval>::int_type
				shift_function(
							   const sc_ufixed<TOTAL_BITS_1,INT_BITS_1,SC_Q_MODE_1,SC_O_MODE_1>& a) {
				typename int_size_needed<INT_BITS_1+Template_Max<TOTAL_BITS_1-INT_BITS_1,FRAC_BITS_>::maxval>::int_type x;
				if (TOTAL_BITS_1-INT_BITS_1>FRAC_BITS_) {
					x = (a.getVal() >> Abs_Func<TOTAL_BITS_1-INT_BITS_1-FRAC_BITS_>::val);
				} else {
					x = (a.getVal() << Abs_Func<TOTAL_BITS_1-INT_BITS_1-FRAC_BITS_>::val);
				}
				return (x);
			}
		}; // end of class 
		/// Specialize for SC_RND shift return type one extra bit to avoid overflow,
		template <> template<int FRAC_BITS_> 
			class sc_shift_class_function<FRAC_BITS_,SC_RND> {
		public:
			/// Specialized shift function for SC_RND
			template <int TOTAL_BITS_1, int INT_BITS_1,
				sc_q_mode SC_Q_MODE_1, sc_o_mode SC_O_MODE_1>
				static typename int_size_needed<INT_BITS_1+Template_Max<TOTAL_BITS_1-INT_BITS_1,FRAC_BITS_>::maxval>::int_type
				shift_function(const sc_fixed<TOTAL_BITS_1,INT_BITS_1,SC_Q_MODE_1,SC_O_MODE_1>& a) {
				typename int_size_needed<INT_BITS_1+Template_Max<TOTAL_BITS_1-INT_BITS_1,FRAC_BITS_>::maxval>::int_type x;
				if (TOTAL_BITS_1-INT_BITS_1>FRAC_BITS_) {
					x = (a.getVal() >> Abs_Func<TOTAL_BITS_1-INT_BITS_1-FRAC_BITS_>::val);
					if ((TOTAL_BITS_1-INT_BITS_1)>FRAC_BITS_) 
					x += (a.getVal() >> Abs_Func<TOTAL_BITS_1-INT_BITS_1-FRAC_BITS_-1>::val) & 0x1;
				} else {
					x = (a.getVal() << Abs_Func<TOTAL_BITS_1-INT_BITS_1-FRAC_BITS_>::val);
				}
				return (x);
			}
			template <int TOTAL_BITS_1, int INT_BITS_1,
				sc_q_mode SC_Q_MODE_1, sc_o_mode SC_O_MODE_1>
				static typename int_size_needed<INT_BITS_1+Template_Max<TOTAL_BITS_1-INT_BITS_1,FRAC_BITS_>::maxval>::int_type
				shift_function(const sc_ufixed<TOTAL_BITS_1,INT_BITS_1,SC_Q_MODE_1,SC_O_MODE_1>& a) {
				typename int_size_needed<INT_BITS_1+Template_Max<TOTAL_BITS_1-INT_BITS_1,FRAC_BITS_>::maxval>::int_type x;
				if (TOTAL_BITS_1-INT_BITS_1>FRAC_BITS_) {
					x = (a.getVal() >> Abs_Func<TOTAL_BITS_1-INT_BITS_1-FRAC_BITS_>::val);
					if ((TOTAL_BITS_1-INT_BITS_1)>FRAC_BITS_) 
					x += (a.getVal() >> Abs_Func<TOTAL_BITS_1-INT_BITS_1-FRAC_BITS_-1>::val) & 0x1;
				} else {
					x = (a.getVal() << Abs_Func<TOTAL_BITS_1-INT_BITS_1-FRAC_BITS_>::val);
				}
				return (x);
			}
		};	
		/// Specialize for SC_TRN shift return type one extra bit to avoid overflow,
		template <> template<int FRAC_BITS_> 
			class sc_shift_class_function<FRAC_BITS_,SC_TRN> {
		public:
			// Specialized shift function for SC_TRN
			template <int TOTAL_BITS_1, int INT_BITS_1,
				sc_q_mode SC_Q_MODE_1, sc_o_mode SC_O_MODE_1>
				static typename int_size_needed<INT_BITS_1+Template_Max<TOTAL_BITS_1-INT_BITS_1,FRAC_BITS_>::maxval>::int_type
				shift_function(const sc_fixed<TOTAL_BITS_1,INT_BITS_1,SC_Q_MODE_1,SC_O_MODE_1>& a) {
				typename int_size_needed<INT_BITS_1+Template_Max<TOTAL_BITS_1-INT_BITS_1,FRAC_BITS_>::maxval>::int_type x;
				if (TOTAL_BITS_1-INT_BITS_1>FRAC_BITS_) {
					x = (a.getVal() >> Abs_Func<TOTAL_BITS_1-INT_BITS_1-FRAC_BITS_>::val);
				} else {
					x = (a.getVal() << Abs_Func<TOTAL_BITS_1-INT_BITS_1-FRAC_BITS_>::val);
				}
				//				std::cout << " Shift_func " << a.getVal() << " -> " << (int)x << "\n";
				return (x);
			}
			template <int TOTAL_BITS_1, int INT_BITS_1,
				sc_q_mode SC_Q_MODE_1, sc_o_mode SC_O_MODE_1>
				static typename int_size_needed<INT_BITS_1+Template_Max<TOTAL_BITS_1-INT_BITS_1,FRAC_BITS_>::maxval>::int_type
				shift_function(const sc_ufixed<TOTAL_BITS_1,INT_BITS_1,SC_Q_MODE_1,SC_O_MODE_1>& a) {
				typename int_size_needed<INT_BITS_1+Template_Max<TOTAL_BITS_1-INT_BITS_1,FRAC_BITS_>::maxval>::int_type x;
				if (TOTAL_BITS_1-INT_BITS_1>FRAC_BITS_) {
					x = (a.getVal() >> Abs_Func<TOTAL_BITS_1-INT_BITS_1-FRAC_BITS_>::val);
				} else {
					x = (a.getVal() << Abs_Func<TOTAL_BITS_1-INT_BITS_1-FRAC_BITS_>::val);
				}
				return (x);
			}
		};	


    	/// A template class to wrap "saturate" functions that can be specialized for fixed-point types
		template <int TOTAL_BITS_, sc_o_mode SC_O_MODE_> class sc_saturate_class_function {
			public:
			    /// Default saturate function is wrap!
				template <int TOTAL_BITS_1, int INT_BITS_1,
					sc_q_mode SC_Q_MODE_1, sc_o_mode SC_O_MODE_1>
					static typename int_size_needed<TOTAL_BITS_>::int_type
					saturate_sfixed(const sc_fixed<TOTAL_BITS_1,INT_BITS_1,SC_Q_MODE_1,SC_O_MODE_1>& a) {
					typename int_size_needed<TOTAL_BITS_>::int_type x;
					x = a.getVal() & ((max_int_type(1) << (TOTAL_BITS_-1)) - 1);
					return (x);
				}
				template <int TOTAL_BITS_1, int INT_BITS_1,
					sc_q_mode SC_Q_MODE_1, sc_o_mode SC_O_MODE_1>
					static typename int_size_needed<TOTAL_BITS_>::int_type
					saturate_sfixed(const sc_ufixed<TOTAL_BITS_1,INT_BITS_1,SC_Q_MODE_1,SC_O_MODE_1>& a) {
					typename int_size_needed<TOTAL_BITS_>::int_type x;
					x = a.getVal() & ((max_int_type(1) << (TOTAL_BITS_)) - 1);
					return (x);
				}
				static typename int_size_needed<TOTAL_BITS_>::int_type
					saturate(const max_int_type& a) {
					typename int_size_needed<TOTAL_BITS_>::int_type x;
					x = a; // BROKE & ((max_int_type(1) << (TOTAL_BITS_-1)) - 1);
					//					std::cout << "\n def " << SC_O_MODE_ << " saturate_func " << (int)a << " -> " << (int)x << "\n";
					return(x);
				}
				static typename int_size_needed<TOTAL_BITS_>::int_type
					usaturate(const max_int_type& a) {
					typename int_size_needed<TOTAL_BITS_>::int_type x;
					x = a; // BROKE & ((max_int_type(1) << (TOTAL_BITS_-1)) - 1);
					//					std::cout << "\n def " << SC_O_MODE_ << " saturate_func " << (int)a << " -> " << (int)x << "\n";
					return(x);
				}
		}; // end of class 

		/// Specialized for SC_SAT
		template <> template<int TOTAL_BITS_> 
				class sc_saturate_class_function<TOTAL_BITS_,SC_SAT> {
			public:
				/// Specialized Saturate function for SC_SAT
				template <int TOTAL_BITS_1, int INT_BITS_1,
					sc_q_mode SC_Q_MODE_1, sc_o_mode SC_O_MODE_1>
					static typename int_size_needed<TOTAL_BITS_>::int_type
					saturate_function(const sc_fixed<TOTAL_BITS_1,INT_BITS_1,SC_Q_MODE_1,SC_O_MODE_1>& a) {

					typename int_size_needed<TOTAL_BITS_>::int_type x;
					x = (a.getVal() > ((max_int_type(1) << (TOTAL_BITS_-1))-1)) ?
						((max_int_type(1) << (TOTAL_BITS_-1))-1) : 
						(a.getVal() < ((max_int_type(-1) << (TOTAL_BITS_-1)))) ?
						((max_int_type(-1) << (TOTAL_BITS_-1))) : a.getVal();
					//					std::cout << " Saturate_func " << a.getVal() << " -> " << (int)x << "\n";
					//					std::cout << "\n saturate_func " << (int)a << " -> " << (int)x << "\n";
					return (x);
				}
				/// Specialized Saturate function for SC_SAT
				template <int TOTAL_BITS_1, int INT_BITS_1,
					sc_q_mode SC_Q_MODE_1, sc_o_mode SC_O_MODE_1>
					static typename int_size_needed<TOTAL_BITS_>::int_type
					saturate_function(const sc_ufixed<TOTAL_BITS_1,INT_BITS_1,SC_Q_MODE_1,SC_O_MODE_1>& a) {

					typename int_size_needed<TOTAL_BITS_>::int_type x;
					x = (a.getVal() > ((max_int_type(1) << (TOTAL_BITS_))-1)) ?
						((max_int_type(1) << (TOTAL_BITS_))-1) : a.getVal(); 
					return (x);
				}
				static typename int_size_needed<TOTAL_BITS_>::int_type
					saturate(const max_int_type& a) {
					typename int_size_needed<TOTAL_BITS_>::int_type x;
					x = (a > ((max_int_type(1) << (TOTAL_BITS_-1))-1)) ?
						((max_int_type(1) << (TOTAL_BITS_-1))-1) : 
						(a < ((max_int_type(-1) << (TOTAL_BITS_-1)))) ?
						((max_int_type(-1) << (TOTAL_BITS_-1))) : a;
					//					std::cout << "\n saturate_func " << (int)a << " -> " << (int)x << "\n";
					return(x);
				}
				static typename int_size_needed<TOTAL_BITS_>::uint_type
					usaturate(const max_int_type& a) {
					typename int_size_needed<TOTAL_BITS_>::uint_type x;
					x = (a > ((max_int_type(1) << TOTAL_BITS_)-1)) ?
					((max_int_type(1) << TOTAL_BITS_)-1) : (a<0) ? 0 : a;
					return(x);
				}
		};	
} // end namespace sc_ft


#endif
