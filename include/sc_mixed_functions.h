// DO NOT EDIT THIS FILE IT WAS AUTOMATICALLY GENERATED 2013/07/22
////////////////////////////////////////////////////////////////////////////// 
// Copyright© 2013 by Broadcom Corporation. All Rights reserved.
// Original Author : Tony Kirke, Broadcom Corporation.
// This software is available under both the SystemC Open Source License 
// Version 3.1 and the MIT License
//
// The contents of this file are subject to the restrictions and limitations
// set forth in the SystemC Open Source License Version 3.1 (the "License").
// You may not use this file except in compliance with such restrictions and
// limitations. You may obtain instructions on how to receive a copy of the
// License at http://www.accellera.org/. Software distributed by Contributors
// under the License is distributed exclusively on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied.
// See the License for the specific language governing rights and limitations
// under the License.
////////////////////////////////////////////////////////////////////////////// 
// MIT License info:
// Permission is hereby granted, free of charge, to any person obtaining a copy 
// of this software and associated documentation files (the "Software"), to deal 
// in the Software without restriction, including without limitation the rights 
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all 
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
// USE OR OTHER DEALINGS IN THE SOFTWARE.
//
////////////////////////////////////////////////////////////////////////////// 
#ifndef SYSTEMC_SC_FT_SC_FIXED_20130722_MIXED_FUNCTIONS_H_
#define SYSTEMC_SC_FT_SC_FIXED_20130722_MIXED_FUNCTIONS_H_
namespace sc_ft {

// +
template <int T1, int I1, int T2, int I2, sc_q_mode QMODE, sc_q_mode QMODE1, sc_o_mode OMODE, sc_o_mode OMODE1> 
	sc_fixed<
	Template_Max_Total_Bits<T1,I1,T2,I2>::maxval+2,
	Template_Max<I1,I2>::maxval+2,QMODE,OMODE> 
	operator +(const sc_fixed<T1,I1,QMODE,OMODE>& a, 
			   const sc_ufixed<T2,I2,QMODE1,OMODE1>& b) {
	
	sc_fixed<
		Template_Max_Total_Bits<T1,I1,T2,I2>::maxval+2,
		Template_Max<I1,I2>::maxval+2,QMODE,OMODE> tmpa(a);
	sc_fixed<
		Template_Max_Total_Bits<T1,I1,T2,I2>::maxval+2,
		Template_Max<I1,I2>::maxval+2,QMODE,OMODE> tmpb(b);
	tmpa.val += tmpb.getVal();
	return tmpa;
}
// +
template <int T1, int I1, int T2, int I2, sc_q_mode QMODE, sc_q_mode QMODE1, sc_o_mode OMODE, sc_o_mode OMODE1> 
	sc_fixed<
	Template_Max_Total_Bits<T1,I1,T2,I2>::maxval+2,
	Template_Max<I1,I2>::maxval+2,QMODE,OMODE> 
	operator +(const sc_ufixed<T1,I1,QMODE,OMODE>& a, 
			   const sc_fixed<T2,I2,QMODE1,OMODE1>& b) {
	
	sc_fixed<
		Template_Max_Total_Bits<T1,I1,T2,I2>::maxval+2,
		Template_Max<I1,I2>::maxval+2,QMODE,OMODE> tmpa(a);
	sc_fixed<
		Template_Max_Total_Bits<T1,I1,T2,I2>::maxval+2,
		Template_Max<I1,I2>::maxval+2,QMODE,OMODE> tmpb(b);
	tmpa.val += tmpb.getVal();
	return tmpa;
}
// -
template <int T1, int I1, int T2, int I2, sc_q_mode QMODE, sc_q_mode QMODE1, sc_o_mode OMODE, sc_o_mode OMODE1> 
	sc_fixed<
	Template_Max_Total_Bits<T1,I1,T2,I2>::maxval+2,
	Template_Max<I1,I2>::maxval+2,QMODE,OMODE> 
	operator -(const sc_fixed<T1,I1,QMODE,OMODE>& a, 
			   const sc_ufixed<T2,I2,QMODE1,OMODE1>& b) {
	
	sc_fixed<
		Template_Max_Total_Bits<T1,I1,T2,I2>::maxval+2,
		Template_Max<I1,I2>::maxval+2,QMODE,OMODE> tmpa(a);
	sc_fixed<
		Template_Max_Total_Bits<T1,I1,T2,I2>::maxval+2,
		Template_Max<I1,I2>::maxval+2,QMODE,OMODE> tmpb(b);

	tmpa.val -= tmpb.getVal();
	return tmpa;
}
// -
template <int T1, int I1, int T2, int I2, sc_q_mode QMODE, sc_q_mode QMODE1, sc_o_mode OMODE, sc_o_mode OMODE1> 
	sc_fixed<
	Template_Max_Total_Bits<T1,I1,T2,I2>::maxval+2,
	Template_Max<I1,I2>::maxval+2,QMODE,OMODE> 
	operator -(const sc_ufixed<T1,I1,QMODE,OMODE>& a, 
			   const sc_fixed<T2,I2,QMODE1,OMODE1>& b) {
	
	sc_fixed<
		Template_Max_Total_Bits<T1,I1,T2,I2>::maxval+2,
		Template_Max<I1,I2>::maxval+2,QMODE,OMODE> tmpa(a);
	sc_fixed<
		Template_Max_Total_Bits<T1,I1,T2,I2>::maxval+2,
		Template_Max<I1,I2>::maxval+2,QMODE,OMODE> tmpb(b);

	tmpa.val -= tmpb.getVal();
	return tmpa;
}

// multiplication
template <int TOTAL_BITS_, int INT_BITS_, int TOTAL_BITS_1, int INT_BITS_1, sc_q_mode QMODE, sc_q_mode QMODE1, sc_o_mode OMODE, sc_o_mode OMODE1> 
	sc_fixed<(TOTAL_BITS_+TOTAL_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE> 
	operator *(const sc_fixed<TOTAL_BITS_,INT_BITS_,QMODE,OMODE>& a, const sc_ufixed<TOTAL_BITS_1,INT_BITS_1,QMODE1,OMODE1>& b) {
	
	sc_fixed<(TOTAL_BITS_+TOTAL_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE> tmp;
	typedef typename sc_fixed<(TOTAL_BITS_+TOTAL_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE>::val_type mult_val_type;
	// Don't need to saturate here!
	tmp.val = (mult_val_type)(a.getVal())*(mult_val_type)(b.getVal());
	return tmp;
}
// multiplication
template <int TOTAL_BITS_, int INT_BITS_, int TOTAL_BITS_1, int INT_BITS_1, sc_q_mode QMODE, sc_q_mode QMODE1, sc_o_mode OMODE, sc_o_mode OMODE1> 
	sc_fixed<(TOTAL_BITS_+TOTAL_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE> 
	operator *(const sc_ufixed<TOTAL_BITS_,INT_BITS_,QMODE,OMODE>& a, const sc_fixed<TOTAL_BITS_1,INT_BITS_1,QMODE1,OMODE1>& b) {
	
	sc_fixed<(TOTAL_BITS_+TOTAL_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE> tmp;
	typedef typename sc_fixed<(TOTAL_BITS_+TOTAL_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE>::val_type mult_val_type;
	// Don't need to saturate here!
	tmp.val = (mult_val_type)(a.getVal())*(mult_val_type)(b.getVal());
	return tmp;
}
 

// division
template <int TOTAL_BITS_, int INT_BITS_, int TOTAL_BITS_1, int INT_BITS_1, sc_q_mode QMODE, sc_q_mode QMODE1, sc_o_mode OMODE, sc_o_mode OMODE1> 
	sc_fixed<(TOTAL_BITS_+TOTAL_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE> 
	operator /(const sc_fixed<TOTAL_BITS_,INT_BITS_,QMODE,OMODE>& a, const sc_ufixed<TOTAL_BITS_1,INT_BITS_1,QMODE1,OMODE1>& b) {
	
	sc_fixed<(TOTAL_BITS_+TOTAL_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE> tmp;
	typedef typename sc_fixed<(TOTAL_BITS_+TOTAL_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE>::val_type mult_val_type;
	// Don't need to saturate here!
	tmp.val = (mult_val_type)(a.getVal())/(mult_val_type)(b.getVal());
	return tmp;
}
 


template <int TOTAL_BITS_, int INT_BITS_, int INT_BITS_1, sc_q_mode QMODE, sc_o_mode OMODE> 
	sc_fixed<(TOTAL_BITS_+INT_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE> 
	operator *(const sc_ufixed<TOTAL_BITS_,INT_BITS_,QMODE,OMODE>& a, 
			   const sc_int<INT_BITS_1>& b) {
	
	sc_fixed<(TOTAL_BITS_+INT_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE> tmp;
	typedef typename sc_fixed<(TOTAL_BITS_+INT_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE>::val_type mult_val_type;
	tmp.val = (mult_val_type)(a.getVal())*(mult_val_type)b.to_int();
	return tmp;
}
template <int TOTAL_BITS_, int INT_BITS_, int INT_BITS_1, sc_q_mode QMODE, sc_o_mode OMODE> 
	sc_fixed<(TOTAL_BITS_+INT_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE> 
	operator *(const sc_int<INT_BITS_1>& b,
	           const sc_ufixed<TOTAL_BITS_,INT_BITS_,QMODE,OMODE>& a) {
	sc_fixed<(TOTAL_BITS_+INT_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE> tmp;
	typedef typename sc_fixed<(TOTAL_BITS_+INT_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE>::val_type mult_val_type;
	tmp.val = (mult_val_type)(a.getVal())*(mult_val_type)b.to_int();
	return tmp;
}

template <int TOTAL_BITS_, int INT_BITS_, int INT_BITS_1, sc_q_mode QMODE, sc_o_mode OMODE> 
	sc_fixed<(TOTAL_BITS_+INT_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE> 
	 operator *(const sc_int<INT_BITS_1>& b,
				const sc_fixed<TOTAL_BITS_,INT_BITS_,QMODE,OMODE>& a) {
	 
	 sc_fixed<(TOTAL_BITS_+INT_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE> tmp;
	 typedef typename sc_fixed<(TOTAL_BITS_+INT_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE>::val_type mult_val_type;
	 tmp.val = b*a.getVal();
	 return tmp;
}
 
template <int TOTAL_BITS_, int INT_BITS_, int INT_BITS_1, sc_q_mode QMODE, sc_o_mode OMODE> 
	sc_fixed<(TOTAL_BITS_+INT_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE> 
	 operator *(const sc_fixed<TOTAL_BITS_,INT_BITS_,QMODE,OMODE>& a,
	            const sc_int<INT_BITS_1>& b) {
	 
	 sc_fixed<(TOTAL_BITS_+INT_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE> tmp;
	 typedef typename sc_fixed<(TOTAL_BITS_+INT_BITS_1),(INT_BITS_+INT_BITS_1),QMODE,OMODE>::val_type mult_val_type;
	 tmp.val = b*a.getVal();
	 return tmp;
 }
 

// ^
template <int TOTAL_BITS_, int INT_BITS_, int TOTAL_BITS_1, int INT_BITS_1, sc_q_mode QMODE, sc_q_mode QMODE1, sc_o_mode OMODE, sc_o_mode OMODE1> 
	bool operator ==(const sc_fixed<TOTAL_BITS_,INT_BITS_,QMODE,OMODE>& a, const sc_ufixed<TOTAL_BITS_1,INT_BITS_1,QMODE1,OMODE1>& b) {
	sc_fixed<Template_Max_Total_Bits<TOTAL_BITS_,INT_BITS_,TOTAL_BITS_1,INT_BITS_1>::maxval+2,Template_Max<INT_BITS_,INT_BITS_1>::maxval+2,QMODE,OMODE> tmpa(a);
	sc_fixed<Template_Max_Total_Bits<TOTAL_BITS_,INT_BITS_,TOTAL_BITS_1,INT_BITS_1>::maxval+2,Template_Max<INT_BITS_,INT_BITS_1>::maxval+2,QMODE,OMODE> tmpb(b);
	return (tmpa.val == tmpb.val);
}
template <int TOTAL_BITS_, int INT_BITS_, int TOTAL_BITS_1, int INT_BITS_1, sc_q_mode QMODE, sc_q_mode QMODE1, sc_o_mode OMODE, sc_o_mode OMODE1> 
	bool operator <(const sc_fixed<TOTAL_BITS_,INT_BITS_,QMODE,OMODE>& a, const sc_ufixed<TOTAL_BITS_1,INT_BITS_1,QMODE1,OMODE1>& b) {
	    sc_fixed<Template_Max_Total_Bits<TOTAL_BITS_,INT_BITS_,TOTAL_BITS_1,INT_BITS_1>::maxval+2,Template_Max<INT_BITS_,INT_BITS_1>::maxval+2,QMODE,OMODE> tmpa(a);
	    sc_fixed<Template_Max_Total_Bits<TOTAL_BITS_,INT_BITS_,TOTAL_BITS_1,INT_BITS_1>::maxval+2,Template_Max<INT_BITS_,INT_BITS_1>::maxval+2,QMODE,OMODE> tmpb(b);
		return (tmpa.val < tmpb.val);
}
// re-use previous operators
template <int TOTAL_BITS_, int INT_BITS_, int TOTAL_BITS_1, int INT_BITS_1, sc_q_mode QMODE, sc_q_mode QMODE1, sc_o_mode OMODE, sc_o_mode OMODE1> 
	bool operator !=(const sc_fixed<TOTAL_BITS_,INT_BITS_,QMODE,OMODE>& a, const sc_ufixed<TOTAL_BITS_1,INT_BITS_1,QMODE1,OMODE1>& b) {
	    sc_fixed<Template_Max_Total_Bits<TOTAL_BITS_,INT_BITS_,TOTAL_BITS_1,INT_BITS_1>::maxval+2,Template_Max<INT_BITS_,INT_BITS_1>::maxval+2,QMODE,OMODE> tmpa(a);
	    sc_fixed<Template_Max_Total_Bits<TOTAL_BITS_,INT_BITS_,TOTAL_BITS_1,INT_BITS_1>::maxval+2,Template_Max<INT_BITS_,INT_BITS_1>::maxval+2,QMODE,OMODE> tmpb(b);
		return !(tmpa.val == tmpb.val);
}
template <int TOTAL_BITS_, int INT_BITS_, int TOTAL_BITS_1, int INT_BITS_1, sc_q_mode QMODE, sc_q_mode QMODE1, sc_o_mode OMODE, sc_o_mode OMODE1> 
	bool operator >(const sc_fixed<TOTAL_BITS_,INT_BITS_,QMODE,OMODE>& a, const sc_ufixed<TOTAL_BITS_1,INT_BITS_1,QMODE1,OMODE1>& b) {
	    sc_fixed<Template_Max_Total_Bits<TOTAL_BITS_,INT_BITS_,TOTAL_BITS_1,INT_BITS_1>::maxval+2,Template_Max<INT_BITS_,INT_BITS_1>::maxval+2,QMODE,OMODE> tmpa(a);
	    sc_fixed<Template_Max_Total_Bits<TOTAL_BITS_,INT_BITS_,TOTAL_BITS_1,INT_BITS_1>::maxval+2,Template_Max<INT_BITS_,INT_BITS_1>::maxval+2,QMODE,OMODE> tmpb(b);
		return (tmpb.val < tmpa.val);
}
template <int TOTAL_BITS_, int INT_BITS_, int TOTAL_BITS_1, int INT_BITS_1, sc_q_mode QMODE, sc_q_mode QMODE1, sc_o_mode OMODE, sc_o_mode OMODE1> 
	bool operator <=(const sc_fixed<TOTAL_BITS_,INT_BITS_,QMODE,OMODE>& a, const sc_ufixed<TOTAL_BITS_1,INT_BITS_1,QMODE1,OMODE1>& b) {
	    sc_fixed<Template_Max_Total_Bits<TOTAL_BITS_,INT_BITS_,TOTAL_BITS_1,INT_BITS_1>::maxval+2,Template_Max<INT_BITS_,INT_BITS_1>::maxval+2,QMODE,OMODE> tmpa(a);
	    sc_fixed<Template_Max_Total_Bits<TOTAL_BITS_,INT_BITS_,TOTAL_BITS_1,INT_BITS_1>::maxval+2,Template_Max<INT_BITS_,INT_BITS_1>::maxval+2,QMODE,OMODE> tmpb(b);
		return !(tmpb.val < tmpa.val);
}
template <int TOTAL_BITS_, int INT_BITS_, int TOTAL_BITS_1, int INT_BITS_1, sc_q_mode QMODE, sc_q_mode QMODE1, sc_o_mode OMODE, sc_o_mode OMODE1> 
	bool operator >=(const sc_fixed<TOTAL_BITS_,INT_BITS_,QMODE,OMODE>& a, const sc_ufixed<TOTAL_BITS_1,INT_BITS_1,QMODE1,OMODE1>& b) {
	    sc_fixed<Template_Max_Total_Bits<TOTAL_BITS_,INT_BITS_,TOTAL_BITS_1,INT_BITS_1>::maxval+2,Template_Max<INT_BITS_,INT_BITS_1>::maxval+2,QMODE,OMODE> tmpa(a);
	    sc_fixed<Template_Max_Total_Bits<TOTAL_BITS_,INT_BITS_,TOTAL_BITS_1,INT_BITS_1>::maxval+2,Template_Max<INT_BITS_,INT_BITS_1>::maxval+2,QMODE,OMODE> tmpb(b);
		return !(tmpa.val < tmpb.val);
}





} // end namespace sc_ft


#endif
